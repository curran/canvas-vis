//@ sourceMappingURL=all.map
// Generated by CoffeeScript 1.6.1
(function() {
  var __slice = [].slice;

  define([], function() {
    var Attribute, BufferedComponent, Collection, Container, LinearContainer, MarkSet, Model, Relation, ScatterPlot, Tuple, Viewport, ViewportContainer, alias, expectProperties, mark, match;
    match = function(property, fns, fnName) {
      if (fnName == null) {
        fnName = 'obj';
      }
      return function(obj) {
        var fn;
        fn = fns[obj[property]];
        if (fn) {
          return fn.apply(null, arguments);
        } else {
          throw Error("no match for " + fnName + "." + property + " = " + tree.type);
        }
      };
    };
    Model = Backbone.Model;
    Collection = Backbone.Collection;
    BufferedComponent = Component.extend({
      initialize: function() {
        var _this = this;
        if (!this.get('component')) {
          throw Error(" BufferedComponent constructor\nexpects a `component` property, which was not given ");
        }
        return (this.get('component')).on('graphicsDirty', function() {
          return _this.trigger('graphicsDirty');
        });
      }
    });
    Container = Component.extend({
      initialize: function() {
        var _this = this;
        if (!this.get('children')) {
          this.set('children', new Collection);
        }
        return (this.get('children')).on('graphicsDirty', function() {
          return _this.trigger('graphicsDirty');
        });
      }
    });
    LinearContainer = Component.extend();
    ViewportContainer = Component.extend();
    MarkSet = ViewportContainer.extend();
    Relation = Model.extend({
      initialize: function() {
        this.tuples = new Collection({
          model: Tuple
        });
        return this.attributes = new Collection({
          model: Attribute
        });
      },
      addAttribute: function(name) {
        return this.attributes.add(new Attribute({
          name: name
        }));
      },
      addTuple: function(values) {
        return this.tuples.add(new Tuple({
          values: values
        }));
      },
      computeMinMax: function() {
        var _this = this;
        return this.attributes.each(function(attribute) {
          var i;
          i = attribute.index;
          return attribute.set({
            min: _this.tuples.min(function(tuple) {
              return tuple.values[i];
            }),
            max: _this.tuples.max(function(tuple) {
              return tuple.values[i];
            })
          });
        });
      }
    });
    Tuple = Model.extend();
    Attribute = Model.extend();
    Viewport = Model.extend({
      srcToDestPoint: function(srcPoint, outDestPoint) {},
      srcToDestRect: function(srcRect, outDestRect) {},
      project: alias(this('srcToDestRect')),
      destToSrcPoint: function(destPoint, outSrcPoint) {},
      destToSrcRect: function(destRect, outSrcRect) {}
    });
    alias = function(_this, method) {
      return function() {
        return _this[method].call(arguments);
      };
    };
    mark = (function() {
      var defaults, properties, shape, shapes, singleton;
      mark = function() {
        _.extend(properties(defaults));
        return singleton;
      };
      properties = {};
      defaults = {
        bounds: new Rectangle,
        fillStyle: 'black',
        shape: 'square',
        rotation: 0
      };
      singleton = {
        shape: function(shape) {
          properties.shape = shape;
          return this;
        },
        fillStyle: function(cssColorStr) {
          properties.fillStyle = cssColorStr;
          return this;
        },
        bounds: function(x, y, w, h) {
          properties.bounds.setAll(x, y, w, h);
          return this;
        },
        position: function(x, y) {
          properties.bounds.position.set(x, y);
          return this;
        },
        size: function(w, h) {
          if (h == null) {
            h = w;
          }
          properties.bounds.size.set(w, h);
          return this;
        },
        x: function(x) {
          properties.bounds.position.x = x;
          return this;
        },
        y: function(y) {
          properties.bounds.position.y = y;
          return this;
        },
        w: function(w) {
          properties.bounds.size.w = w;
          return this;
        },
        h: function(h) {
          properties.bounds.size.h = h;
          return this;
        },
        rotation: function(rotation) {
          properties.rotation = rotation;
          return this;
        },
        getBounds: function() {
          return shape().bounds();
        },
        render: function(ctx, viewport) {
          return shape().render(ctx, viewport);
        }
      };
      shape = function() {
        if (!shapes[properties.shape]) {
          throw Error("Unknown shape type '" + properties.shape + "'");
        }
        return shapes[properties.shape];
      };
      shapes = {
        square: {
          bounds: function() {
            return properties.bounds.clone();
          },
          render: function(ctx, viewport) {
            var bounds;
            ctx.fillStyle = properties.fillStyle;
            bounds = viewport.project(properties.bounds);
            return ctx.fillRect(bounds.position.x, bounds.position.y, bounds.size.w, bounds.size.h);
          }
        }
      };
      return mark;
    })();
    ScatterPlot = MarkSet.extend({
      initialize: function() {
        return expectProperties('xAttr', 'yAttr');
      },
      generator: function(relation) {
        var tuples;
        tuples = relation.iterator();
        return {
          hasNext: function() {
            return tuples.hasNext();
          },
          next: function() {
            var tuple, x, y;
            tuple = tuples.next();
            x = (this.get('xAttr')).index;
            y = (this.get('yAttr')).index;
            return mark().x(tuple[x].y(tuple[y]));
          }
        };
      }
    });
    return expectProperties = function() {
      var properties, _this;
      _this = arguments[0], properties = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return _.each(properties, function(property) {
        if (!_this.get(property)) {
          throw Error(" Missing expected property\n'" + property + "' in constructor call.");
        }
      });
    };
  });

}).call(this);
