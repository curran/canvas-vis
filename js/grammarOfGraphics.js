//@ sourceMappingURL=grammarOfGraphics.map
// Generated by CoffeeScript 1.6.1
(function() {

  define(['cv/grammarOfGraphics/parser', 'cv/match', 'cv/Varset'], function(parser, match, Varset) {
    var dataStmts, execute, line, printTree, step1, step2, step3;
    execute = function(variables, expression) {
      var tree;
      tree = parser.parse(expression);
      variables = step1(tree, variables);
      tree = step2(tree, variables);
      console.dir(step3(tree, variables));
      return tree;
    };
    dataStmts = [];
    step1 = match('type', 'step1', {
      'statements': function(stmts, variables) {
        var dataStmt, newName, oldName, stmt, _i, _j, _len, _len1, _ref;
        dataStmts = [];
        _ref = stmts.statements;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stmt = _ref[_i];
          step1(stmt);
        }
        for (_j = 0, _len1 = dataStmts.length; _j < _len1; _j++) {
          dataStmt = dataStmts[_j];
          oldName = dataStmt.oldName;
          newName = dataStmt.newName;
          variables[newName] = variables[oldName];
        }
        return variables;
      },
      'data': function(data) {
        return dataStmts.push(data);
      },
      'statement': function() {}
    });
    step2 = match('type', 'step2', {
      'statements': function(stmts, vars) {
        var stmt;
        return {
          type: 'statements',
          statements: (function() {
            var _i, _len, _ref, _results;
            _ref = stmts.statements;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              stmt = _ref[_i];
              _results.push(step2(stmt, vars));
            }
            return _results;
          })()
        };
      },
      'data': function(data, vars) {
        return data;
      },
      'statement': match('statementType', 'step2', {
        ELEMENT: function(stmt, vars) {
          return {
            type: 'statement',
            statementType: 'ELEMENT',
            expr: step2(stmt.expr, vars)
          };
        },
        TRANS: function(stmt, vars) {
          return stmt;
        },
        SCALE: function(stmt, vars) {
          return stmt;
        },
        COORD: function(stmt, vars) {
          return stmt;
        },
        GUIDE: function(stmt, vars) {
          return stmt;
        }
      }),
      'function': function(fn, vars) {
        var arg;
        return {
          type: 'function',
          name: fn.name,
          args: (function() {
            var _i, _len, _ref, _results;
            _ref = fn.args;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              arg = _ref[_i];
              _results.push(step2(arg, vars));
            }
            return _results;
          })()
        };
      },
      'cross': function(cross, vars) {
        var left, right;
        left = step2(cross.left, vars);
        right = step2(cross.right, vars);
        return Varset.cross(left, right);
      },
      'name': function(name, vars) {
        return Varset.fromVariable(vars[name.name]);
      }
    });
    step3 = match('type', 'step3', {
      'statements': function(stmts) {
        var scales, stmt;
        scales = (function() {
          var _i, _len, _ref, _results;
          _ref = stmts.statements;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stmt = _ref[_i];
            _results.push(step3(stmt));
          }
          return _results;
        })();
        return _.extend.apply(null, scales);
      },
      'data': function(data) {
        return {};
      },
      'statement': match('statementType', 'step3.statement', {
        ELEMENT: function(stmt) {
          return {};
        },
        TRANS: function(stmt) {
          return {};
        },
        SCALE: function(stmt) {
          return step3(stmt.expr);
        },
        COORD: function(stmt) {
          return {};
        },
        GUIDE: function(stmt) {
          return {};
        }
      }),
      'function': match('name', 'step3.function', {
        'linear': function(fn) {
          var dim, result;
          if (fn.args.length !== 1) {
            throw Error('linear() expects one argument');
          }
          dim = step3(fn.args[0]);
          result = {};
          result[dim] = {
            type: 'linear'
          };
          return result;
        },
        'dim': function(fn) {
          if (fn.args.length !== 1) {
            throw Error('dim() expects one argument');
          }
          if (fn.args[0].type !== 'number') {
            throw Error('dim() expects a numeric argument');
          }
          return fn.args[0].value;
        }
      })
    });
    printTree = function(tree) {
      var p;
      p = match('type', 'printTree', {
        statements: function(statements, indent) {
          var i, s, ss, _ref;
          _ref = [statements.statements, indent], ss = _ref[0], i = _ref[1];
          return line(i + 'statements') + ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = ss.length; _i < _len; _i++) {
              s = ss[_i];
              _results.push(p(s, i + '  '));
            }
            return _results;
          })()).join('');
        },
        statement: function(stmt, indent) {
          return [line(indent + 'statement: ' + stmt.statementType), p(stmt.expr, indent + '  ')].join('');
        },
        data: function(data, indent) {
          return line(indent + ("statement: DATA " + data.newName + " = \"" + data.oldName + "\""));
        },
        name: function(name, indent) {
          return line(indent + 'name ' + name.name);
        },
        number: function(number, indent) {
          return line(indent + 'number ' + number.value);
        },
        string: function(string, indent) {
          return line(indent + 'string ' + string.value);
        },
        cross: function(cross, indent) {
          return [line(indent + 'cross'), line(indent + '  left'), p(cross.left, indent + '    '), line(indent + '  right'), p(cross.right, indent + '    ')].join('');
        },
        assignment: function(assignment, indent) {
          return [line(indent + 'assignment'), line(indent + '  left'), p(assignment.left, indent + '    '), line(indent + '  right'), p(assignment.right, indent + '    ')].join('');
        },
        "function": function(fn, indent) {
          var arg;
          return [
            line(indent + 'function ' + fn.name), line(indent + '  args:'), ((function() {
              var _i, _len, _ref, _results;
              _ref = fn.args;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                arg = _ref[_i];
                _results.push(p(arg, indent + '    '));
              }
              return _results;
            })()).join('')
          ].join('');
        },
        varset: function(varset, indent) {
          return indent + '<varset>';
        }
      });
      return p(tree, '');
    };
    line = function(str) {
      return str + '\n';
    };
    return {
      execute: execute,
      step1: step1,
      step2: step2
    };
  });

}).call(this);
