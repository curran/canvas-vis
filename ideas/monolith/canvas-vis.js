// Generated by CoffeeScript 1.6.1
(function() {
  var Point, Rect, Scale, Viewport, app, ctx, e, express, inNode, match, port, t, type,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  type = function(obj, t) {
    var shouldError;
    if (obj === void 0) {
      throw Error('First argument to type() is null');
    }
    if (t === void 0) {
      throw Error('Second argument to type() is null');
    }
    shouldError = (function() {
      switch (t) {
        case Number:
          return typeof obj !== 'number';
        case String:
          return typeof obj !== 'string';
        default:
          return obj.constructor !== t;
      }
    })();
    if (shouldError) {
      throw Error('Type Error');
    }
  };

  match = function(fns) {
    return function(obj) {
      var constructor, fn;
      constructor = obj.constructor;
      fn = fns[constructor.name];
      while (!fn && constructor.__super__) {
        constructor = constructor.__super__.constructor;
        fn = fns[constructor.name];
      }
      if (fn) {
        return fn.apply(this, arguments);
      } else {
        throw Error("no match for type " + constructor.name + ".");
      }
    };
  };

  Point = (function() {

    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      type(this.x, Number);
      type(this.y, Number);
    }

    return Point;

  })();

  Rect = (function() {

    function Rect(x, y, w, h) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.w = w != null ? w : 1;
      this.h = h != null ? h : 1;
      type(this.x, Number);
      type(this.y, Number);
      type(this.w, Number);
      type(this.h, Number);
    }

    return Rect;

  })();

  Viewport = (function() {

    function Viewport(src, dest) {
      this.src = src != null ? src : new Rect;
      this.dest = dest != null ? dest : new Rect;
      type(this.src, Rect);
      type(this.dest, Rect);
    }

    Viewport.prototype.project = match({
      Point: function(inPt, outPt) {
        var d, s;
        type(inPt, Point);
        type(outPt, Point);
        s = this.src;
        d = this.dest;
        outPt.x = (inPt.x - s.x) / s.w * d.w + d.x;
        return outPt.y = (inPt.y - s.y) / s.h * d.h + d.y;
      },
      Rect: function(inRect, outRect) {
        var d, s;
        type(inRect, Rect);
        type(outRect, Rect);
        s = this.src;
        d = this.dest;
        outRect.x = (inRect.x - s.x) / s.w * d.w + d.x;
        outRect.y = (inRect.y - s.y) / s.h * d.h + d.y;
        outRect.w = inRect.w * d.w / s.w;
        return outRect.h = inRect.h * d.h / s.h;
      }
    });

    return Viewport;

  })();

  Scale = (function() {

    function Scale(values) {
      this.min = _.min(values);
      this.max = _.max(values);
    }

    Scale.prototype.normalize = function(value) {
      return (value - this.min) / (this.max - this.min);
    };

    return Scale;

  })();

  t = function() {
    var Animal, Horse, Snake, dest, inPt, outPt, sam, sayHello, scale, src, tom, viewport;
    Animal = (function() {

      function Animal(name) {
        this.name = name;
      }

      return Animal;

    })();
    Snake = (function(_super) {

      __extends(Snake, _super);

      function Snake() {
        return Snake.__super__.constructor.apply(this, arguments);
      }

      return Snake;

    })(Animal);
    Horse = (function(_super) {

      __extends(Horse, _super);

      function Horse() {
        return Horse.__super__.constructor.apply(this, arguments);
      }

      return Horse;

    })(Animal);
    sam = new Snake("Sammy the Python");
    tom = new Horse("Tommy the Palomino");
    sayHello = match({
      Snake: function(snake) {
        return "I am " + snake.name + ", hiss!";
      },
      Animal: function(animal) {
        return "I am " + animal.name + ", an animal.";
      }
    });
    e(sayHello(sam), 'I am Sammy the Python, hiss!');
    e(sayHello(tom), 'I am Tommy the Palomino, an animal.');
    e((new Point(4, 6)).x, 4);
    e((new Rect(5, 6, 7, 8)).w, 7);
    src = new Rect(0, 0, 1, 1);
    dest = new Rect(2, 4, 6, 8);
    viewport = new Viewport(src, dest);
    inPt = new Point(0.5, 0.75);
    outPt = new Point;
    viewport.project(inPt, outPt);
    e(outPt.x, 5);
    e(outPt.y, 10);
    scale = new Scale([4, 5, 6, 8]);
    return e(scale.normalize(7), 0.75);
  };

  e = function(actual, expected) {
    if (actual !== expected) {
      throw new Error("Expected " + expected + ", got " + actual);
    }
  };

  inNode = typeof module !== 'undefined';

  if (inNode) {
    GLOBAL._ = require('underscore');
    t();
    console.log('All tests passed!');
    express = require('express');
    app = express();
    port = 8080;
    app.use(express["static"](__dirname));
    app.use(express.directory(__dirname));
    app.listen(port);
    console.log("Serving at localhost:" + port);
  } else {
    t();
    console.log('All tests passed!');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx = canvas.getContext('2d');
    ctx.fillStyle = 'darkBlue';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    $.get('iris.csv', function(data) {
      var columnNames, dest, inPt, margin, maxRadius, minRadius, outPt, points, r, rIndex, rScale, radius, rect, rs, src, table, tuple, tuples, unit, viewport, xIndex, xScale, xs, yIndex, yScale, ys, _i, _len, _results;
      table = $.csv.toArrays(data);
      columnNames = _.first(table);
      tuples = _.rest(table);
      xIndex = 0;
      xs = _.map(tuples, function(tuple) {
        return tuple[xIndex];
      });
      xScale = new Scale(xs);
      yIndex = 1;
      ys = _.map(tuples, function(tuple) {
        return tuple[yIndex];
      });
      yScale = new Scale(ys);
      rIndex = 1;
      rs = _.map(tuples, function(tuple) {
        return tuple[rIndex];
      });
      rScale = new Scale(rs);
      unit = new Rect(0, 0, 1, 1);
      margin = 0.1;
      src = new Rect(-margin, -margin, 1 + 2 * margin, 1 + 2 * margin);
      dest = new Rect(0, 0, canvas.width, canvas.height);
      viewport = new Viewport(src, dest);
      rect = new Rect;
      viewport.project(unit, rect);
      ctx.fillStyle = 'orange';
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      inPt = new Point;
      outPt = new Point;
      minRadius = 5;
      maxRadius = 10;
      points = [];
      _results = [];
      for (_i = 0, _len = tuples.length; _i < _len; _i++) {
        tuple = tuples[_i];
        inPt.x = xScale.normalize(tuple[xIndex]);
        inPt.y = yScale.normalize(tuple[yIndex]);
        viewport.project(inPt, outPt);
        r = rScale.normalize(tuple[rIndex]);
        radius = minRadius + r * (maxRadius - minRadius);
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(outPt.x, outPt.y, radius, 0, 2 * Math.PI);
        ctx.closePath();
        _results.push(ctx.fill());
      }
      return _results;
    });
  }

}).call(this);
