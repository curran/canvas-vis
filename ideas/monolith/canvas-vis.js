// Generated by CoffeeScript 1.6.1
(function() {
  var Attribute, Interval, Point, Rect, Relation, Scale, Viewport, app, ctx, e, express, inNode, match, port, t, type,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  type = function(obj, t) {
    var shouldError;
    if (obj === void 0) {
      throw Error('First argument to type() is null');
    }
    if (t === void 0) {
      throw Error('Second argument to type() is null');
    }
    shouldError = (function() {
      switch (t) {
        case Number:
          return typeof obj !== 'number';
        case String:
          return typeof obj !== 'string';
        default:
          return obj.constructor !== t;
      }
    })();
    if (shouldError) {
      throw Error('Type Error');
    }
  };

  match = function(fns) {
    return function(obj) {
      var constructor, fn;
      constructor = obj.constructor;
      fn = fns[constructor.name];
      while (!fn && constructor.__super__) {
        constructor = constructor.__super__.constructor;
        fn = fns[constructor.name];
      }
      if (fn) {
        return fn.apply(this, arguments);
      } else {
        throw Error("no match for type " + constructor.name + ".");
      }
    };
  };

  Point = (function() {

    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      type(this.x, Number);
      type(this.y, Number);
    }

    return Point;

  })();

  Rect = (function() {

    function Rect(x, y, w, h) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.w = w != null ? w : 1;
      this.h = h != null ? h : 1;
      type(this.x, Number);
      type(this.y, Number);
      type(this.w, Number);
      type(this.h, Number);
    }

    return Rect;

  })();

  Viewport = (function() {

    function Viewport(src, dest) {
      this.src = src != null ? src : new Rect;
      this.dest = dest != null ? dest : new Rect;
      type(this.src, Rect);
      type(this.dest, Rect);
    }

    Viewport.prototype.project = match({
      Point: function(inPt, outPt) {
        var d, s;
        type(inPt, Point);
        type(outPt, Point);
        s = this.src;
        d = this.dest;
        outPt.x = (inPt.x - s.x) / s.w * d.w + d.x;
        return outPt.y = (inPt.y - s.y) / s.h * d.h + d.y;
      },
      Rect: function(inRect, outRect) {
        var d, s;
        type(inRect, Rect);
        type(outRect, Rect);
        s = this.src;
        d = this.dest;
        outRect.x = (inRect.x - s.x) / s.w * d.w + d.x;
        outRect.y = (inRect.y - s.y) / s.h * d.h + d.y;
        outRect.w = inRect.w * d.w / s.w;
        return outRect.h = inRect.h * d.h / s.h;
      }
    });

    return Viewport;

  })();

  Interval = (function() {

    function Interval(min, max) {
      this.min = min;
      this.max = max;
      type(this.min, Number);
      type(this.max, Number);
    }

    Interval.prototype.span = function() {
      return this.max - this.min;
    };

    Interval.prototype.to = function(interval, value) {
      type(interval, Interval);
      type(value, Number);
      return (value - this.min) / this.span() * interval.span() + interval.min;
    };

    return Interval;

  })();

  Scale = (function() {

    function Scale(attribute) {
      var values;
      this.attribute = attribute;
      type(this.attribute, Attribute);
      values = this.attribute.values();
      this.src = new Interval(_.min(values), _.max(values));
      this.dest = new Interval(0, 1);
    }

    Scale.prototype.normalize = function(key) {
      return this.src.to(this.dest, this.attribute.map[key]);
    };

    return Scale;

  })();

  Relation = (function() {

    function Relation(table) {
      var i, key, m, map, n, name, names, tuple, tuples, _i, _results;
      names = _.first(table);
      tuples = _.rest(table);
      n = names.length;
      m = tuples.length;
      this.keys = (function() {
        _results = [];
        for (var _i = 0; 0 <= m ? _i < m : _i > m; 0 <= m ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      this.attributes = (function() {
        var _j, _k, _len, _ref, _results1;
        _results1 = [];
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          name = names[i];
          map = {};
          _ref = this.keys;
          for (_k = 0, _len = _ref.length; _k < _len; _k++) {
            key = _ref[_k];
            tuple = tuples[key];
            map[key] = parseFloat(tuple[i]);
          }
          _results1.push(new Attribute(name, this.keys, map));
        }
        return _results1;
      }).call(this);
    }

    Relation.prototype.attribute = function(name) {
      return _.findWhere(this.attributes, {
        name: name
      });
    };

    return Relation;

  })();

  Attribute = (function() {

    function Attribute(name, keys, map) {
      this.name = name;
      this.keys = keys;
      this.map = map;
    }

    Attribute.prototype.values = function() {
      var key, _i, _len, _ref, _results;
      _ref = this.keys;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _results.push(this.map[key]);
      }
      return _results;
    };

    return Attribute;

  })();

  t = function() {
    var Animal, Horse, Snake, dest, inPt, outPt, sam, sayHello, src, tom, viewport;
    Animal = (function() {

      function Animal(name) {
        this.name = name;
      }

      return Animal;

    })();
    Snake = (function(_super) {

      __extends(Snake, _super);

      function Snake() {
        return Snake.__super__.constructor.apply(this, arguments);
      }

      return Snake;

    })(Animal);
    Horse = (function(_super) {

      __extends(Horse, _super);

      function Horse() {
        return Horse.__super__.constructor.apply(this, arguments);
      }

      return Horse;

    })(Animal);
    sam = new Snake("Sammy the Python");
    tom = new Horse("Tommy the Palomino");
    sayHello = match({
      Snake: function(snake) {
        return "I am " + snake.name + ", hiss!";
      },
      Animal: function(animal) {
        return "I am " + animal.name + ", an animal.";
      }
    });
    e(sayHello(sam), 'I am Sammy the Python, hiss!');
    e(sayHello(tom), 'I am Tommy the Palomino, an animal.');
    e((new Point(4, 6)).x, 4);
    e((new Rect(5, 6, 7, 8)).w, 7);
    src = new Rect(0, 0, 1, 1);
    dest = new Rect(2, 4, 6, 8);
    viewport = new Viewport(src, dest);
    inPt = new Point(0.5, 0.75);
    outPt = new Point;
    viewport.project(inPt, outPt);
    e(outPt.x, 5);
    return e(outPt.y, 10);
  };

  e = function(actual, expected) {
    if (actual !== expected) {
      throw new Error("Expected " + expected + ", got " + actual);
    }
  };

  inNode = typeof module !== 'undefined';

  if (inNode) {
    GLOBAL._ = require('underscore');
    t();
    console.log('All tests passed!');
    express = require('express');
    app = express();
    port = 8080;
    app.use(express["static"](__dirname));
    app.use(express.directory(__dirname));
    app.listen(port);
    console.log("Serving at localhost:" + port);
  } else {
    t();
    console.log('All tests passed!');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx = canvas.getContext('2d');
    ctx.fillStyle = 'darkBlue';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    $.get('iris.csv', function(data) {
      var dest, inPt, key, margin, outPt, rScale, radius, rect, relation, src, table, unit, viewport, xScale, yScale, _i, _len, _ref, _results;
      table = $.csv.toArrays(data);
      relation = new Relation(table);
      xScale = new Scale(relation.attribute('sepal length'));
      yScale = new Scale(relation.attribute('sepal width'));
      rScale = new Scale(relation.attribute('petal width'));
      rScale.dest = new Interval(3, 20);
      unit = new Rect(0, 0, 1, 1);
      margin = 0.1;
      src = new Rect(-margin, -margin, 1 + 2 * margin, 1 + 2 * margin);
      dest = new Rect(0, 0, canvas.width, canvas.height);
      viewport = new Viewport(src, dest);
      rect = new Rect;
      viewport.project(unit, rect);
      ctx.fillStyle = 'orange';
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      inPt = new Point;
      outPt = new Point;
      _ref = relation.keys;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        inPt.x = xScale.normalize(key);
        inPt.y = yScale.normalize(key);
        radius = rScale.normalize(key);
        viewport.project(inPt, outPt);
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(outPt.x, outPt.y, radius, 0, 2 * Math.PI);
        ctx.closePath();
        _results.push(ctx.fill());
      }
      return _results;
    });
  }

}).call(this);
